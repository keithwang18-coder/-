<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Happy Christmas 姜丝</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background-color: #050103; color: white; }
        #canvas-container { width: 100%; height: 100%; display: block; }
        
        /* Intro UI Styles */
        #intro-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(16px);
            z-index: 50;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            transition: opacity 1s ease-out, visibility 1s;
        }
        #intro-overlay.hidden { opacity: 0; visibility: hidden; pointer-events: none; }
        
        .glow-border {
            box-shadow: 0 0 30px rgba(230, 57, 104, 0.4);
            border: 1px solid rgba(236, 72, 153, 0.3);
        }
        
        .title-text {
            font-family: 'Playfair Display', serif;
            background: linear-gradient(to right, #fbcfe8, #ffffff, #fbcfe8);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-shadow: 0 4px 12px rgba(0,0,0,0.5);
        }

        /* Loading Spinner */
        #loader {
            position: absolute; bottom: 20px; right: 20px; color: #ff9eaa; font-size: 12px; letter-spacing: 2px;
            display: block;
        }
    </style>

    <!-- Import Map for CDN modules -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://esm.sh/three@0.160.0",
                "three/addons/": "https://esm.sh/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <!-- 3D Canvas Container -->
    <div id="canvas-container"></div>

    <!-- Intro Overlay -->
    <div id="intro-overlay">
        <div class="flex flex-col items-center max-w-md p-8 text-center space-y-8 animate-[fadeIn_0.7s_ease-out]">
            
            <!-- Photo Container -->
            <div class="relative w-auto h-64 aspect-[3/4] rounded-2xl overflow-hidden glow-border">
                <img 
                    src="https://images.unsplash.com/photo-1607262807149-dfd4c39320a6?auto=format&fit=crop&w=600&q=80" 
                    alt="Christmas Tree Cookie" 
                    class="w-full h-full object-cover bg-black/20"
                    crossorigin="anonymous"
                />
            </div>

            <h1 class="text-5xl md:text-6xl title-text">
                Happy Christmas <br/>
                <span class="text-4xl md:text-5xl italic text-pink-400">姜丝</span>
            </h1>

            <button id="enter-btn" class="group relative px-8 py-3 bg-transparent overflow-hidden rounded-full border border-pink-500/50 text-white shadow-[0_0_20px_rgba(255,105,180,0.3)] transition-all hover:shadow-[0_0_40px_rgba(255,105,180,0.6)] hover:border-pink-400 cursor-pointer">
                <div class="absolute inset-0 w-0 bg-gradient-to-r from-pink-600 to-purple-600 transition-all duration-[250ms] ease-out group-hover:w-full opacity-20"></div>
                <span class="relative tracking-[0.2em] font-light">ENTER</span>
            </button>
        </div>
    </div>

    <!-- UI Controls -->
    <div id="ui-layer" class="hidden absolute inset-0 pointer-events-none z-40">
        <button id="audio-btn" class="fixed top-6 right-6 pointer-events-auto p-3 bg-white/10 backdrop-blur-md rounded-full text-white hover:bg-white/20 transition-all border border-white/10">
            <!-- Audio Icon (SVG) -->
            <svg id="icon-sound-on" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path></svg>
            <svg id="icon-sound-off" class="hidden" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><line x1="23" y1="9" x2="17" y2="15"></line><line x1="17" y1="9" x2="23" y2="15"></line></svg>
        </button>
        <div class="fixed bottom-8 left-0 right-0 text-center opacity-50 text-xs tracking-widest font-light">
            CLICK ANYWHERE TO <span id="mode-text">EXPLODE</span>
        </div>
    </div>
    
    <div id="loader">LOADING RESOURCES...</div>

    <!-- Main Application Logic -->
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- Configuration (Matching React Components) ---
        const CONFIG = {
            colors: {
                warmRose: new THREE.Color('#E63968'),
                softCherry: new THREE.Color('#FF9EAA'),
                champagne: new THREE.Color('#FFF0D4'),
                warmYellow: new THREE.Color('#FFD700'),
            },
            counts: {
                leaves: 18000,
                gems: 3000,
                ribbons: 2000
            },
            musicUrl: "https://cdn.pixabay.com/audio/2022/11/22/audio_febc508520.mp3"
        };

        // --- State ---
        const state = {
            mode: 'TREE', // 'TREE' or 'EXPLODE'
            progress: 0, // 0 to 1
            isMuted: false,
            isPlaying: false
        };

        // --- Math Utils ---
        const randomRange = (min, max) => Math.random() * (max - min) + min;
        
        const getConePoint = (height, radiusBase) => {
            const y = Math.random() * height;
            const r = (radiusBase * (height - y)) / height;
            const theta = Math.random() * Math.PI * 2;
            const radius = Math.sqrt(Math.random()) * r;
            return new THREE.Vector3(radius * Math.cos(theta), y - height / 2, radius * Math.sin(theta));
        };

        const getSpherePoint = (radius) => {
            const u = Math.random();
            const v = Math.random();
            const theta = 2 * Math.PI * u;
            const phi = Math.acos(2 * v - 1);
            const r = Math.cbrt(Math.random()) * radius;
            const sinPhi = Math.sin(phi);
            return new THREE.Vector3(r * sinPhi * Math.cos(theta), r * sinPhi * Math.sin(theta), r * Math.cos(phi));
        };

        const getSpiralPoint = (t, height, radiusBase, turns) => {
            const y = t * height - height / 2;
            const r = (radiusBase * (1 - t)) + 0.5;
            const theta = t * Math.PI * 2 * turns;
            return new THREE.Vector3(r * Math.cos(theta), y, r * Math.sin(theta));
        };

        // --- Scene Setup ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2('#050103', 0.02);

        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 2, 28);

        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ReinhardToneMapping;
        renderer.toneMappingExposure = 1.8;
        container.appendChild(renderer.domElement);

        // --- Controls ---
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enablePan = false;
        controls.minDistance = 10;
        controls.maxDistance = 50;
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.rotateSpeed = 0.5;

        // --- Lighting (Matching Experience.tsx) ---
        const ambientLight = new THREE.AmbientLight('#331015', 1.5);
        scene.add(ambientLight);

        const spotLight1 = new THREE.SpotLight('#F06292', 30);
        spotLight1.position.set(10, 10, -10);
        spotLight1.angle = 0.5;
        spotLight1.penumbra = 1;
        scene.add(spotLight1);

        const spotLight2 = new THREE.SpotLight('#FFDAB9', 22);
        spotLight2.position.set(-10, 8, -10);
        spotLight2.angle = 0.6;
        spotLight2.penumbra = 1;
        scene.add(spotLight2);

        const upLight = new THREE.PointLight('#FFF5E1', 12, 20);
        upLight.position.set(0, -5, 5);
        scene.add(upLight);

        // --- Objects Container ---
        const treeGroup = new THREE.Group();
        scene.add(treeGroup);

        // --- Instance Data Helper ---
        function createInstancedSystem(count, geometry, material, getTreePos, getColor) {
            const mesh = new THREE.InstancedMesh(geometry, material, count);
            const dummy = new THREE.Object3D();
            const data = [];

            for (let i = 0; i < count; i++) {
                const treePos = getTreePos(i);
                const explodePos = getSpherePoint(20); 
                const scale = randomRange(0.02, 0.08);
                const speed = randomRange(0.2, 1.0);
                
                const color = getColor ? getColor(i) : new THREE.Color(0xffffff);
                
                dummy.position.copy(treePos);
                dummy.scale.setScalar(scale);
                dummy.updateMatrix();
                mesh.setMatrixAt(i, dummy.matrix);
                mesh.setColorAt(i, color);

                data.push({ treePos, explodePos, scale, speed, color });
            }
            
            mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
            treeGroup.add(mesh);
            return { mesh, data, dummy };
        }

        // 1. LEAVES
        const leafGeo = new THREE.OctahedronGeometry(1, 0);
        const leafMat = new THREE.MeshStandardMaterial({
            roughness: 0.4, metalness: 0.6, color: '#FFB6C1', emissive: CONFIG.colors.warmRose, emissiveIntensity: 0.3
        });
        const leavesSystem = createInstancedSystem(CONFIG.counts.leaves, leafGeo, leafMat, 
            () => getConePoint(12, 4),
            () => Math.random() > 0.5 ? CONFIG.colors.warmRose : CONFIG.colors.softCherry
        );

        // 2. GEMS
        const gemGeo = new THREE.IcosahedronGeometry(1, 0);
        const gemMat = new THREE.MeshStandardMaterial({
            roughness: 0.1, metalness: 0.9, emissive: CONFIG.colors.champagne, emissiveIntensity: 0.5
        });
        const gemsSystem = createInstancedSystem(CONFIG.counts.gems, gemGeo, gemMat, 
            () => getConePoint(12, 4.2),
            () => Math.random() > 0.3 ? CONFIG.colors.champagne : CONFIG.colors.warmRose
        );

        // 3. RIBBONS
        const starShape = new THREE.Shape();
        const pts = 5;
        for (let i = 0; i < pts * 2; i++) {
            const r = i % 2 === 0 ? 1 : 0.4;
            const a = (i / (pts * 2)) * Math.PI * 2;
            i === 0 ? starShape.moveTo(Math.cos(a)*r, Math.sin(a)*r) : starShape.lineTo(Math.cos(a)*r, Math.sin(a)*r);
        }
        const ribbonGeo = new THREE.ShapeGeometry(starShape);
        const ribbonMat = new THREE.MeshBasicMaterial({ color: CONFIG.colors.champagne, side: THREE.DoubleSide });
        const ribbonSystem = createInstancedSystem(CONFIG.counts.ribbons, ribbonGeo, ribbonMat, 
            (i) => getSpiralPoint(i / CONFIG.counts.ribbons, 13, 5.5, 3.5),
            () => CONFIG.colors.champagne
        );

        // 4. SPARKLES (Custom Shader to mimic Drei Sparkles)
        function createSparkles(count, size, color, speed, area) {
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(count * 3);
            const sizes = new Float32Array(count);
            const speeds = new Float32Array(count);
            const phases = new Float32Array(count);

            for (let i = 0; i < count; i++) {
                let pos;
                if(area === 'tree') pos = getConePoint(12, 4.5);
                else if(area === 'star') pos = new THREE.Vector3(0, 6.5, 0).add(getSpherePoint(1.5));
                else pos = getSpherePoint(10); // ribbon area approx

                // Adjustment for ribbon sparkles
                if (area === 'ribbon') {
                     // rough approx around origin but spread out
                     pos = new THREE.Vector3(
                        (Math.random()-0.5)*10, 
                        (Math.random()-0.5)*12, 
                        (Math.random()-0.5)*10
                     );
                }

                positions[i * 3] = pos.x;
                positions[i * 3 + 1] = pos.y;
                positions[i * 3 + 2] = pos.z;
                
                sizes[i] = Math.random();
                speeds[i] = speed * (0.5 + Math.random());
                phases[i] = Math.random() * Math.PI * 2;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            geometry.setAttribute('speed', new THREE.BufferAttribute(speeds, 1));
            geometry.setAttribute('phase', new THREE.BufferAttribute(phases, 1));

            // Custom Shader Material for blinking
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0 },
                    uColor: { value: new THREE.Color(color) },
                    uBaseSize: { value: size * (window.devicePixelRatio) }
                },
                vertexShader: `
                    uniform float uTime;
                    uniform float uBaseSize;
                    attribute float size;
                    attribute float speed;
                    attribute float phase;
                    varying float vAlpha;
                    void main() {
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        gl_Position = projectionMatrix * mvPosition;
                        
                        // Blink logic
                        float blink = 0.5 + 0.5 * sin(uTime * speed + phase);
                        vAlpha = blink;
                        
                        gl_PointSize = uBaseSize * size * (10.0 / -mvPosition.z);
                    }
                `,
                fragmentShader: `
                    uniform vec3 uColor;
                    varying float vAlpha;
                    void main() {
                        // Circular particle
                        vec2 cxy = 2.0 * gl_PointCoord - 1.0;
                        float r = dot(cxy, cxy);
                        if (r > 1.0) discard;
                        
                        gl_FragColor = vec4(uColor, vAlpha);
                    }
                `,
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });

            const points = new THREE.Points(geometry, material);
            return points;
        }

        // Add Sparkles Groups
        const sparklesRibbon = createSparkles(500, 4.0, CONFIG.colors.champagne, 2.0, 'ribbon'); 
        treeGroup.add(sparklesRibbon);

        const sparklesTree = createSparkles(500, 6.0, CONFIG.colors.softCherry, 1.5, 'tree'); 
        treeGroup.add(sparklesTree);

        // 5. TOP STAR
        const topStarShape = new THREE.Shape();
        for (let i = 0; i < 10; i++) {
            const r = i % 2 === 0 ? 0.8 : 0.4;
            const a = (i / 10) * Math.PI * 2;
            i === 0 ? topStarShape.moveTo(Math.cos(a)*r, Math.sin(a)*r) : topStarShape.lineTo(Math.cos(a)*r, Math.sin(a)*r);
        }
        const topStarGeo = new THREE.ExtrudeGeometry(topStarShape, { depth: 0.2, bevelEnabled: true, bevelThickness: 0.1, bevelSize: 0.1, bevelSegments: 2 });
        const topStarMat = new THREE.MeshStandardMaterial({ 
            color: CONFIG.colors.warmYellow, 
            emissive: CONFIG.colors.warmYellow, 
            emissiveIntensity: 2.1 
        });
        const topStar = new THREE.Mesh(topStarGeo, topStarMat);
        topStar.position.y = 6.5;
        treeGroup.add(topStar);
        
        const starSparkles = createSparkles(80, 5.0, CONFIG.colors.warmYellow, 3.0, 'star');
        treeGroup.add(starSparkles);

        // --- Post Processing ---
        const composer = new EffectComposer(renderer);
        const renderPass = new RenderPass(scene, camera);
        composer.addPass(renderPass);

        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.3, 0.6, 1.1);
        composer.addPass(bloomPass);

        // --- Audio ---
        const audio = new Audio(CONFIG.musicUrl);
        audio.loop = true;
        audio.volume = 0.4;

        // --- Interaction Logic ---
        const clock = new THREE.Clock();
        
        function updateSystem(system, t, time) {
            const { mesh, data, dummy } = system;
            for (let i = 0; i < data.length; i++) {
                const d = data[i];
                dummy.position.lerpVectors(d.treePos, d.explodePos, t);
                dummy.position.y += Math.sin(time * d.speed + i) * 0.05;
                dummy.rotation.set(time * d.speed * 0.2, time * d.speed * 0.1, 0);
                
                let s = d.scale * (1 - t * 0.3);
                if (mesh === gemsSystem.mesh) s *= (1 + Math.sin(time * 5 + i) * 0.2);
                dummy.scale.setScalar(s);

                if (mesh === ribbonSystem.mesh) {
                   dummy.lookAt(camera.position);
                   dummy.rotateZ(time * d.speed);
                }

                dummy.updateMatrix();
                mesh.setMatrixAt(i, dummy.matrix);
            }
            mesh.instanceMatrix.needsUpdate = true;
        }

        function animate() {
            requestAnimationFrame(animate);
            
            const delta = clock.getDelta();
            const time = clock.getElapsedTime();

            // 1. Lerp State Progress
            const target = state.mode === 'EXPLODE' ? 1 : 0;
            state.progress += (target - state.progress) * 2.5 * delta;

            // 2. Rotate Group
            treeGroup.rotation.y += delta * 0.1;

            // 3. Top Star Animation
            topStar.rotation.y = time * 0.5;
            topStar.rotation.z = Math.sin(time) * 0.1;
            topStar.position.y = 6.5 + Math.sin(time * 2) * 0.2;
            
            // Sync star sparkles position roughly
            starSparkles.position.y = Math.sin(time * 2) * 0.2; 

            // 4. Update Particles
            updateSystem(leavesSystem, state.progress, time);
            updateSystem(gemsSystem, state.progress, time);
            updateSystem(ribbonSystem, state.progress, time);
            
            // Update Sparkles Uniforms
            sparklesRibbon.material.uniforms.uTime.value = time;
            sparklesTree.material.uniforms.uTime.value = time;
            starSparkles.material.uniforms.uTime.value = time;

            controls.update();
            composer.render();
        }

        // --- Event Listeners ---

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        document.getElementById('enter-btn').addEventListener('click', () => {
            const intro = document.getElementById('intro-overlay');
            const ui = document.getElementById('ui-layer');
            const loader = document.getElementById('loader');
            
            intro.classList.add('hidden');
            if(loader) loader.style.display = 'none';

            setTimeout(() => {
                intro.style.display = 'none';
                ui.classList.remove('hidden');
                ui.classList.add('flex');
            }, 1000);

            state.isPlaying = true;
            audio.play().catch(e => console.log("Audio play failed", e));
        });

        const audioBtn = document.getElementById('audio-btn');
        const iconOn = document.getElementById('icon-sound-on');
        const iconOff = document.getElementById('icon-sound-off');

        audioBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            if (state.isMuted) {
                audio.play();
                state.isMuted = false;
                iconOn.classList.remove('hidden');
                iconOff.classList.add('hidden');
            } else {
                audio.pause();
                state.isMuted = true;
                iconOn.classList.add('hidden');
                iconOff.classList.remove('hidden');
            }
        });

        document.addEventListener('click', (e) => {
            if (e.target.closest('button')) return;
            if (!state.isPlaying) return;

            state.mode = state.mode === 'TREE' ? 'EXPLODE' : 'TREE';
            const txt = document.getElementById('mode-text');
            txt.innerText = state.mode === 'TREE' ? 'EXPLODE' : 'ASSEMBLE';
        });

        animate();

    </script>
</body>
</html>